/*!
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("react"),require("prop-types")):"function"==typeof define&&define.amd?define(["react","prop-types"],e):"object"==typeof exports?exports.CKEditor=e(require("react"),require("prop-types")):t.CKEditor=e(t.react,t["prop-types"])}(self,((t,e)=>(()=>{"use strict";var o={949:t=>{t.exports=e},155:e=>{e.exports=t}},r={};function n(t){var e=r[t];if(void 0!==e)return e.exports;var a=r[t]={exports:{}};return o[t](a,a.exports,n),a.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var o in e)n.o(e,o)&&!n.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var a={};return(()=>{n.r(a),n.d(a,{CKEditor:()=>l,CKEditorContext:()=>c,useMultiRootEditor:()=>R});var t=n(155),e=n.n(t),o=n(949),r=n.n(o);const i=new Array(256).fill("").map(((t,e)=>("0"+e.toString(16)).slice(-2)));const s=e().createContext("contextWatchdog");class c extends e().Component{constructor(t,e){super(t,e),this.contextWatchdog=null,this.props.isLayoutReady&&this._initializeContextWatchdog(this.props.config)}shouldComponentUpdate(t){return this._shouldComponentUpdate(t)}async _shouldComponentUpdate(t){return t.id!==this.props.id&&(this.contextWatchdog&&await this.contextWatchdog.destroy(),await this._initializeContextWatchdog(t.config)),t.isLayoutReady&&!this.contextWatchdog?(await this._initializeContextWatchdog(t.config),!0):this.props.children!==t.children}render(){return e().createElement(s.Provider,{value:this.contextWatchdog},this.props.children)}componentWillUnmount(){this._destroyContext()}async _initializeContextWatchdog(t){this.contextWatchdog=new this.props.contextWatchdog(this.props.context,this.props.watchdogConfig),this.contextWatchdog.on("error",((t,e)=>{this.props.onError(e.error,{phase:"runtime",willContextRestart:e.causesRestart})})),this.contextWatchdog.on("stateChange",(()=>{"ready"===this.contextWatchdog.state&&this.props.onReady&&this.props.onReady(this.contextWatchdog.context)})),await this.contextWatchdog.create(t).catch((t=>{this.props.onError(t,{phase:"initialization",willContextRestart:!1})}))}async _destroyContext(){this.contextWatchdog&&(await this.contextWatchdog.destroy(),this.contextWatchdog=null)}}c.defaultProps={isLayoutReady:!0,onError:(t,e)=>console.error(t,e)},c.propTypes={id:r().string,isLayoutReady:r().bool,context:r().func,watchdogConfig:r().object,config:r().object,onReady:r().func,onError:r().func};class u{constructor(t,e){this._releaseLock=null,this._value=null,this._afterMountCallbacks=[],this._state={destroyedBeforeInitialization:!1,mountingInProgress:null},this.release=function(t){let e=null;return(...o)=>(e||(e={current:t(...o)}),e.current)}((()=>{const{_releaseLock:t,_state:e,_element:o,_lifecycle:r}=this;e.mountingInProgress?e.mountingInProgress.then((()=>r.unmount({element:o,mountResult:this.value}))).catch((t=>{console.error("Semaphore unmounting error:",t)})).then(t.resolve).then((()=>{this._value=null})):(e.destroyedBeforeInitialization=!0,t.resolve())})),this._element=t,this._lifecycle=e,this._lock()}get value(){return this._value}unsafeSetValue(t){this._value=t,this._afterMountCallbacks.forEach((e=>e(t))),this._afterMountCallbacks=[]}runAfterMount(t){const{_value:e,_afterMountCallbacks:o}=this;e?t(e):o.push(t)}_lock(){const{_semaphores:t}=u,{_state:e,_element:o,_lifecycle:r}=this,n=t.get(o)||Promise.resolve(null),a=function(){const t={resolve:null,promise:null};return t.promise=new Promise((e=>{t.resolve=e})),t}();this._releaseLock=a;const i=n.then((()=>e.destroyedBeforeInitialization?Promise.resolve(void 0):(e.mountingInProgress=r.mount().then((t=>(t&&this.unsafeSetValue(t),t))),e.mountingInProgress))).then((async t=>{t&&r.afterMount&&await r.afterMount({element:o,mountResult:t})})).then((()=>a.promise)).catch((t=>{console.error("Semaphore mounting error:",t)})).then((()=>{t.get(o)===i&&t.delete(o)}));t.set(o,i)}}u._semaphores=new Map;const d="Lock from React integration (@ckeditor/ckeditor5-react)";class l extends e().Component{constructor(t){super(t),this.domContainer=e().createRef(),this.editorSemaphore=null,this._checkVersion()}_checkVersion(){const{CKEDITOR_VERSION:t}=window;if(!t)return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');const[e]=t.split(".").map(Number);e>=42||t.startsWith("0.0.0")||console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.")}get _semaphoreValue(){const{editorSemaphore:t}=this;return t?t.value:null}get watchdog(){const{_semaphoreValue:t}=this;return t?t.watchdog:null}get editor(){const{_semaphoreValue:t}=this;return t?t.instance:null}shouldComponentUpdate(t){const{props:e,editorSemaphore:o}=this;return t.id!==e.id||(t.disableWatchdog!==e.disableWatchdog||(o&&(o.runAfterMount((({instance:o})=>{this._shouldUpdateEditorData(e,t,o)&&o.data.set(t.data)})),"disabled"in t&&o.runAfterMount((({instance:e})=>{t.disabled?e.enableReadOnlyMode(d):e.disableReadOnlyMode(d)}))),!1))}componentDidMount(){this._initLifeCycleSemaphore()}componentDidUpdate(){this._initLifeCycleSemaphore()}componentWillUnmount(){this._unlockLifeCycleSemaphore()}_unlockLifeCycleSemaphore(){this.editorSemaphore&&(this.editorSemaphore.release(),this.editorSemaphore=null)}_initLifeCycleSemaphore(){this._unlockLifeCycleSemaphore(),this.editorSemaphore=new u(this.domContainer.current,{mount:async()=>this._initializeEditor(),afterMount:({mountResult:t})=>{const{onReady:e}=this.props;e&&null!==this.domContainer.current&&e(t.instance)},unmount:async({element:t,mountResult:e})=>{const{onAfterDestroy:o}=this.props;try{await this._destroyEditor(e),t.innerHTML=""}finally{o&&o(e.instance)}}})}render(){return e().createElement("div",{ref:this.domContainer})}async _initializeEditor(){if(this.props.disableWatchdog){return{instance:await this._createEditor(this.domContainer.current,this._getConfig()),watchdog:null}}const t=(()=>this.context instanceof this.props.editor.ContextWatchdog?new h(this.context):new this.props.editor.EditorWatchdog(this.props.editor,this.props.watchdogConfig))(),e={current:0};return t.setCreator((async(o,r)=>{const{editorSemaphore:n}=this,{onAfterDestroy:a}=this.props;e.current>0&&a&&n&&n.value&&n.value.instance&&a(n.value.instance);const i=await this._createEditor(o,r);return e.current>0&&(n.unsafeSetValue({instance:i,watchdog:t}),setTimeout((()=>{this.props.onReady&&this.props.onReady(t.editor)}))),e.current++,i})),t.on("error",((t,{error:e,causesRestart:o})=>{(this.props.onError||console.error)(e,{phase:"runtime",willEditorRestart:o})})),await t.create(this.domContainer.current,this._getConfig()).catch((t=>{(this.props.onError||console.error)(t,{phase:"initialization",willEditorRestart:!1})})),{watchdog:t,instance:t.editor}}_createEditor(t,e){return this.props.editor.create(t,e).then((t=>{"disabled"in this.props&&this.props.disabled&&t.enableReadOnlyMode(d);const e=t.model.document,o=t.editing.view.document;return e.on("change:data",(e=>{this.props.onChange&&this.props.onChange(e,t)})),o.on("focus",(e=>{this.props.onFocus&&this.props.onFocus(e,t)})),o.on("blur",(e=>{this.props.onBlur&&this.props.onBlur(e,t)})),t}))}async _destroyEditor(t){const{watchdog:e,instance:o}=t;return new Promise(((t,r)=>{setTimeout((async()=>{try{if(e)return await e.destroy(),t();if(o)return await o.destroy(),t();t()}catch(t){console.error(t),r(t)}}))}))}_shouldUpdateEditorData(t,e,o){return t.data!==e.data&&o.data.get()!==e.data}_getConfig(){const t=this.props.config||{};return this.props.data&&t.initialData&&console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."),{...t,initialData:t.initialData||this.props.data||""}}}l.contextType=s,l.propTypes={editor:r().func.isRequired,data:r().string,config:r().object,disableWatchdog:r().bool,watchdogConfig:r().object,onChange:r().func,onReady:r().func,onFocus:r().func,onBlur:r().func,onError:r().func,disabled:r().bool,id:r().any};class h{constructor(t){this._contextWatchdog=t,this._id=function(){const t=4294967296*Math.random()>>>0,e=4294967296*Math.random()>>>0,o=4294967296*Math.random()>>>0,r=4294967296*Math.random()>>>0;return"e"+i[255&t]+i[t>>8&255]+i[t>>16&255]+i[t>>24&255]+i[255&e]+i[e>>8&255]+i[e>>16&255]+i[e>>24&255]+i[255&o]+i[o>>8&255]+i[o>>16&255]+i[o>>24&255]+i[255&r]+i[r>>8&255]+i[r>>16&255]+i[r>>24&255]}()}setCreator(t){this._creator=t}create(t,e){return this._contextWatchdog.add({sourceElementOrData:t,config:e,creator:this._creator,id:this._id,type:"editor"})}on(t,e){this._contextWatchdog.on("itemError",((t,{itemId:o,error:r})=>{o===this._id&&e(null,{error:r,causesRestart:void 0})}))}destroy(){return"ready"===this._contextWatchdog.state?this._contextWatchdog.remove(this._id):Promise.resolve()}get editor(){return this._contextWatchdog.getItem(this._id)}}function p(...t){return e=>{t.forEach((t=>{"function"==typeof t?t(e):null!=t&&(t.current=e)}))}}function f(t,e){for(const t of Object.getOwnPropertyNames(e))delete e[t];for(const[o,r]of Object.entries(t))r!==e&&"prototype"!==o&&"__proto__"!==o&&(e[o]=r);return e}const m=e=>{const o=(0,t.useRef)();return o.current=e,(0,t.useCallback)(((...t)=>o.current(...t)),[])};function g(t,e){return e.length=0,e.push(...t),e}const y=(e,o,r)=>{((e,o)=>{const r=(0,t.useRef)(null);((t,e)=>{if(t===e)return!0;if(!t||!e)return!1;for(let o=0;o<t.length;++o)if(t[o]!==e[o])return!1;return!0})(r.current,o)||(r.current=[...o],e())})((()=>{e&&e.runAfterMount(o)}),[e,...r])},b="Lock from React integration (@ckeditor/ckeditor5-react)",w=(0,t.memo)((0,t.forwardRef)((({id:o,semaphore:r,rootName:n},a)=>{const i=(0,t.useRef)(null);return(0,t.useEffect)((()=>{let t,e;return r.runAfterMount((({instance:o})=>{i.current&&(e=o,t=o.ui.view.createEditable(n,i.current),o.ui.addEditable(t),o.editing.view.forceRender())})),()=>{t&&i.current&&e&&"destroyed"!==e.state&&e.ui.removeEditable(t)}}),[r.revision]),e().createElement("div",{key:r.revision,id:o,ref:p(a,i)})})));w.displayName="EditorEditable";const _=(0,t.forwardRef)((({editor:o},r)=>{const n=(0,t.useRef)(null);return(0,t.useEffect)((()=>{const t=n.current;if(!o||!t)return;const e=o.ui.view.toolbar.element;return t&&t.appendChild(e),()=>{t&&t.removeChild(e)}}),[o&&o.id]),e().createElement("div",{ref:p(n,r)})}));_.displayName="EditorToolbarWrapper";const R=o=>{const r=(0,t.useRef)(o.semaphoreElement||null),n=(()=>{const e=(0,t.useRef)(null),[o,r]=(0,t.useState)((()=>Date.now())),n=()=>{r(Date.now())},a=(t=!0)=>{e.current&&(e.current.release(),e.current=null),t&&r(Date.now())},i=t=>{e.current&&e.current.runAfterMount(t)};return{get current(){return e.current},revision:o,createAttributeRef:t=>({get current(){return e.current&&e.current.value?e.current.value[t]:null}}),unsafeSetValue:t=>{var o;null===(o=e.current)||void 0===o||o.unsafeSetValue(t),n()},release:a,replace:t=>{a(!1),e.current=t(),n(),i(n)},runAfterMount:i}})(),a={watchdog:n.createAttributeRef("watchdog"),instance:n.createAttributeRef("instance")},i=(0,t.useContext)(s),[c,d]=(0,t.useState)((()=>Object.keys(o.data))),[l,p]=(0,t.useState)({...o.data}),[R,C]=(0,t.useState)({...o.rootsAttributes}),v=(0,t.useRef)(!0);(0,t.useEffect)((()=>{const t=r.current;if(t&&!1!==o.isLayoutReady)return n.replace((()=>new u(t,{mount:O,afterMount:({mountResult:t})=>{const{onReady:e}=o;e&&null!==r.current&&e(t.instance)},unmount:async({element:t,mountResult:e})=>{const{onAfterDestroy:r}=o;try{await M(e),t.innerHTML=""}finally{r&&r(e.instance)}}}))),()=>{n.release(!1)}}),[o.id,o.isLayoutReady]);const E=()=>{const t=o.config||{};return o.data&&t.initialData&&console.warn("Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified."),{...t,rootsAttributes:R}},x=m(((t,e)=>{const r=t.model.document;if(!o.disableTwoWayDataBinding){const e={},o={};r.differ.getChanges().forEach((o=>{let r;if(r="insert"==o.type||"remove"==o.type?o.position.root:o.range.root,!r.isAttached())return;const{rootName:n}=r;e[n]=t.getData({rootName:n})})),r.differ.getChangedRoots().forEach((r=>{if(r.state)return void(void 0!==e[r.name]&&delete e[r.name]);const n=r.name;o[n]=t.getRootAttributes(n)})),Object.keys(e).length&&p((t=>({...t,...e}))),Object.keys(o).length&&C((t=>({...t,...o})))}o.onChange&&o.onChange(e,t)})),W=m(((t,e,r)=>{const n=r.rootName;o.disableTwoWayDataBinding||(p((e=>({...e,[n]:t.getData({rootName:n})}))),C((e=>({...e,[n]:t.getRootAttributes(n)})))),d((t=>{return e=[...t,r.rootName],Array.from(new Set(e));var e}))})),k=m(((t,e,r)=>{const n=r.rootName;o.disableTwoWayDataBinding||(p((t=>{const{[n]:e,...o}=t;return{...o}})),C((t=>{const{[n]:e,...o}=t;return{...o}}))),d((t=>t.filter((t=>t!==n))))})),S=m(((t,e)=>(f({...o.rootsAttributes},R),f({...o.data},l),g(Object.keys(o.data),c),o.editor.create(t,e).then((t=>{const e=t.getFullData();f({...e},l),f({...t.getRootsAttributes()},R),g(Object.keys(e),c),o.disabled&&t.enableReadOnlyMode(b);const r=t.model.document,n=t.editing.view.document;return r.on("change:data",(e=>x(t,e))),t.on("addRoot",((e,o)=>W(t,e,o))),t.on("detachRoot",((e,o)=>k(t,e,o))),n.on("focus",(e=>{o.onFocus&&o.onFocus(e,t)})),n.on("blur",(e=>{o.onBlur&&o.onBlur(e,t)})),t}))))),M=t=>{const{watchdog:e,instance:o}=t;return new Promise(((t,r)=>{setTimeout((async()=>{try{if(e)return await e.destroy(),t();if(o)return await o.destroy(),t();t()}catch(t){console.error(t),r(t)}}))}))},O=async()=>{if(o.disableWatchdog){return{instance:await S(o.data,E()),watchdog:null}}const t=i instanceof o.editor.ContextWatchdog?new h(i):new o.editor.EditorWatchdog(o.editor,o.watchdogConfig),e={current:0};return t.setCreator((async(r,i)=>{const{onAfterDestroy:s}=o;e.current>0&&s&&a.instance.current&&s(a.instance.current);const c=await S(r,i);return e.current>0&&(n.unsafeSetValue({instance:c,watchdog:t}),setTimeout((()=>{o.onReady&&o.onReady(t.editor)}))),e.current++,c})),t.on("error",((t,{error:e,causesRestart:r})=>{(o.onError||console.error)(e,{phase:"runtime",willEditorRestart:r})})),await t.create(l,E()).catch((t=>{throw(o.onError||console.error)(t,{phase:"initialization",willEditorRestart:!1}),t})),{watchdog:t,instance:t.editor}},A=(0,t.useCallback)((t=>{n.runAfterMount((()=>{v.current=!0,p(t)}))}),[p]),D=(0,t.useCallback)((t=>{n.runAfterMount((()=>{v.current=!0,C(t)}))}),[C]),j=e().createElement(_,{ref:r,editor:a.instance.current});y(n.current,(({instance:t})=>{o.disabled?t.enableReadOnlyMode(b):t.disableReadOnlyMode(b)}),[o.disabled]),y(n.current,(({instance:t})=>{if(v.current){v.current=!1;const e=Object.keys(l),o=Object.keys(R);if(!e.every((t=>o.includes(t))))throw console.error("`data` and `attributes` objects must have the same keys (roots)."),new Error("`data` and `attributes` objects must have the same keys (roots).");const r=t.getFullData(),n=t.getRootsAttributes(),{addedKeys:a,removedKeys:i}=((t,e)=>{const o=Object.keys(t),r=Object.keys(e);return{addedKeys:r.filter((t=>!o.includes(t))),removedKeys:o.filter((t=>!r.includes(t)))}})(r,l||{}),s=e.some((t=>void 0!==r[t]&&JSON.stringify(r[t])!==JSON.stringify(l[t]))),c=o.filter((t=>JSON.stringify(n[t])!==JSON.stringify(R[t]))),u=e=>{e.forEach((e=>{t.addRoot(e,{data:l[e]||"",attributes:(null==R?void 0:R[e])||{},isUndoable:!0})}))},d=e=>{e.forEach((e=>{t.detachRoot(e,!0)}))},h=()=>{t.data.set(l,{suppressErrorInCollaboration:!0})},p=(e,o)=>{o.forEach((o=>{Object.keys(R[o]).forEach((e=>{t.registerRootAttribute(e)})),e.clearAttributes(t.model.document.getRoot(o)),e.setAttributes(R[o],t.model.document.getRoot(o))}))};setTimeout((()=>{t.model.change((t=>{u(a),d(i),s&&h(),c.length&&p(t,c)}))}))}}),[l,R]);const T=c.map((t=>e().createElement(w,{key:t,id:t,rootName:t,semaphore:n})));return{editor:a.instance.current,editableElements:T,toolbarElement:j,data:l,setData:A,attributes:R,setAttributes:D}}})(),a})()));
//# sourceMappingURL=index.js.map